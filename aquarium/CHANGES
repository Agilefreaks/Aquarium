== Version 0.1.6

Bug fixes:
14353	Advising subclass method that calls super raises exception when method executed
14356	Regexps for types must cover the whole name, which is inconsistent with method/attribute regexps
14384	Design by Contract "extra" does not return correct value "invar" handling
13410	Fix funky navigation bar on website

14353 was kind of bad, but it's actually a Ruby bug with a good workaround. If you 
advised a method that called "super", Ruby would use the wrong method name to lookup the
class in the parent. See the bug description for the details.

For 14356, type regular expressions now match on parts of names; they don't have to match
the whole name. The exception is regular expressions with module separators "::". In this
case, it seems to make more sense for the regular expression to be interpreted as follows:
If the expression is /A::B::C::D/, then for the the outermost types, the expression behaves
as /^.*A/, for the types between two "::", the expressions behave as /^B$/ and /^C$/, and
the trailing expression behaves as /D.*$/.

14384 was an easy mistake to make with "around" advice; you have to remember to return the 
result of the "join_point.proceed" call, unless you specifically want to change the returned
value! Here are two ways to do it:

	do_something_before(...)
	result = join_point.proceed
	do_something_after(...)
	return result

or
	
	begin
		do_something_before(...)
		join_point.proceed
	ensure
		do_something_after(...)
	end

The latter approach looks "asymmetrical" and it will behave differently if "proceed" raises!
However, it eliminates the temporary, if you find that desirable.
 
Enhancements:
13407	Pick a better method name for JoinPoint#type, which hides the Module#type
14385	Pointcut.new should accept a :join_point => jp argument
14386	Aspect.new ..., :pointcut => should accept a join point object

For 13407, new attribute methods have been added
* JoinPoint#target_type 	return the type that the join_point matches.
* JoinPoint#target_type=	set the type that the join_point matches.
* JoinPoint#target_object 	return the object that the join_point matches.
* JoinPoint#target_object=	set the object that the join_point matches.

The following, older methods are now deprecated and will be removed in the 0.2.0 release (#14053):
* JoinPoint#type
* JoinPoint#type=
* JoinPoint#object
* JoinPoint#object=

JoinPoint#type method is deprecated because it hides Module#type, which returns the type of 
the corresponding object. For "symmetry", the other three methods are also now deprecated and 
they will be removed in a future release. Until then, all will print a warning message to 
STDOUT. (If you really want the type of what could be a JoinPoint object, you should use #class
anyway, as Module#type is also deprecated!)

== Version 0.1.5

Bug fixes:
13514	Protected and private methods are made public when advised and left that way when unadvised
13650	Loading Aquarium interferes with Rails filters
13864	Bug with negative object_id

Enhancements:
13392	Convert examples to specs.
13463	Support running in JRuby

Fixing 13650 required an API change, which is why I've tagged this release "0.1.5" instead of
something like "0.1.1" (and the changes don't seem big enough to warrant "0.2.0"...).

Previously, requiring "aquarium.rb" in the top-level "lib" directory would implicitly require 
lib/aquarium/aspects/dsl/aspect_dsl.rb, which
has Object include the AspectDSL module. This module adds methods like :before and :after to Object. 
Unfortunately, those methods collide with methods of the same name that Rails adds to Object. It was 
also a bit presumptuous of me to assume that everyone wanted those methods on Object ;)

In this release, aspect_dsl.rb is still implicitly included and it still defines the AspectDSL 
module. Now, however, it does not include the AspectDSL module in Object. Instead, if you want this 
behavior for all types, you must require the new lib/aquarium/aspects/dsl/object_dsl.rb explicitly. 

As an alternative, if you just want the AspectDSL module included selectively in certain types, 
then do the following:

	class MyClass   # reopen "MyClass"
		# Add the methods as _class_ methods
		include Aquarium::Aspects::DSL::AspectDSL
	end

or, use (class|module)_eval:

	require 'aquarium/aspects/dsl/aspect_dsl'

	MyClass.class_eval do
		# Add the methods as _class_ methods
		include Aquarium::Aspects::DSL::AspectDSL
	end

To add the methods as _instance_ methods on individual objects:

	object = MyClass.new
	object.extend(Aquarium::Aspects::DSL::AspectDSL)


Note: as discussed at http://practicalruby.blogspot.com/2007/02/reopen-with-moduleeval.html, 
using "class_eval" or "module_eval" is safer that just reopening a class if 
you're not sure that "MyClass" has actually been defined yet. However, in our particular case, it 
probably doesn't matter, as AspectDSL doesn't change anything about the type, like aliasing existing 
methods. Still, we can't guarantee that this won't change in the future.

== Version 0.1.0

This is the initial version.

